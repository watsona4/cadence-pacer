<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content="A mobile-friendly cadence pacer app for indoor cycling. Set your RPM, control your workout flow, and train with synchronized audio cues and dark mode support. Works offline as a PWA."/>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="Cadence">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="theme-color" content="#ffffff" />
    <link rel="apple-touch-icon" href="/cadence/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/cadence/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/cadence/favicon-16x16.png">
    <link rel="icon" type="image/x-icon" href="/cadence/favicon.ico">
    <link rel="manifest" href="/cadence/manifest.json">
    <title>Bike Cadence Pacer</title>

    <!-- Bootstrap 5 + Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.css" rel="stylesheet" />
    <style>
      input[type=range].form-range {
          height: 2.25rem;
          background-color: transparent;
          appearance: none;
          -webkit-appearance: none;
      }

      input[type=range].form-range::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          background-color: #0d6efd;
          width: 1rem;
          height: 1rem;
          border-radius: 50%;
          cursor: pointer;
      }

      input[type=range].form-range::-webkit-slider-runnable-track {
          background: #dee2e6;
          height: 0.25rem;
          border-radius: 0.25rem;
      }

      input[type=range].form-range:focus {
          outline: none;
      }

      input[type=range]::-moz-range-thumb {
          background: #0d6efd;
          border: none;
          width: 1rem;
          height: 1rem;
          border-radius: 50%;
          cursor: pointer;
      }

      input[type=range]::-moz-range-track {
          background: #dee2e6;
          height: 0.25rem;
          border-radius: 0.25rem;
      }
      .btn {
          font-size: 2rem;
          padding: 1rem 1.5rem;
      }
      .btn i {
          font-size: 1.8rem;
      }
    </style>
  </head>
  <body class="bg-light text-center py-3">
    <div class="container">
      <h1 class="mb-4">Bike Cadence Pacer</h1>
      <h2 class="display-3 my-3" id="currentRPMDisplay">85 RPM</h2>

      <div class="mb-4">
        <button id="startButton" onclick="togglePacer()" class="btn btn-primary w-100 mb-2 fs-2">
          <i class="bi bi-play-fill me-2"></i>Start
        </button>
        <button id="setRPMButton" onclick="setRPM()" class="btn btn-secondary w-100 mb-2 fs-2" disabled>
          <i class="bi bi-sliders me-2"></i>Set RPM
        </button>
        <button id="standUpButton" onclick="standUp()" class="btn btn-warning w-100 mb-2 fs-2" disabled>
          <i class="bi bi-person-standing me-2"></i>Stand Up
        </button>
        <button id="cooldownButton" onclick="startCooldown()" class="btn btn-info w-100 mb-2 fs-2" disabled>
          <i class="bi bi-snow me-2"></i>Cooldown
        </button>
      </div>

      <div class="mb-4">
        <label for="rpmSlider" class="form-label fs-3">Target RPM: <span id="rpmVal">90</span></label>
        <input type="range" class="form-range" id="rpmSlider" min="50" max="120" step="5" value="90" />
      </div>

      <div class="mb-4">
        <label for="cooldownSlider" class="form-label fs-3">Cooldown Duration (minutes): <span id="cooldownVal">5</span></label>
        <input type="range" class="form-range" id="cooldownSlider" min="1" max="5" step="1" value="5" />
        <div id="countdown" class="mt-3 fs-1 fw-semibold"></div>
      </div>
    </div>

    <script>
      const tickURL = './tick.wav';
      const tockURL = './tock.wav';
      const chimeURL = './chime.wav';
      const currentRPMDisplay = document.getElementById('currentRPMDisplay');
      const rpmSlider = document.getElementById('rpmSlider');
      const rpmVal = document.getElementById('rpmVal');
      const cooldownSlider = document.getElementById('cooldownSlider');
      const cooldownVal = document.getElementById('cooldownVal');
      const countdownDisplay = document.getElementById('countdown');

      const audioContext = new (window.AudioContext || window.webkitAudioContext)();

      let wakeLock = null;

      async function requestWakeLock() {
          try {
              if ('wakeLock' in navigator) {
                  wakeLock = await navigator.wakeLock.request('screen');
                  console.log('Wake lock is active');
                  wakeLock.addEventListener('release', () => {
                      console.log('Wake lock released');
                  });
              }
          } catch (err) {
              console.error(`Wake lock request failed: ${err.name}, ${err.message}`);
          }
      }

      function releaseWakeLock() {
          if (wakeLock) {
              wakeLock.release();
              wakeLock = null;
          }
      }

      let tickBuffer, tockBuffer, chimeBuffer;
      let cadenceBeat = 0;
      let cadenceLoopActive = false;
      let intervalId;
      let countdownInterval;
      let cooldownTimer;
      let currentRPM = 85;
      let silentSource;

      // --- Set RPM flip-flop state ---
      let slotA = null;          // first chosen target
      let slotB = null;          // second chosen target
      let sliderSlot = 'A';      // which slot the slider currently represents (A or B)

      // --- Cooldown state for resume after Stand Up ---
      let cooldownActive = false;
      let cooldownStartMs = 0;
      let cooldownDurationMs = 0;
      let cooldownStartRPM = 85; // captured at cooldown start

      releaseWakeLock();

      rpmSlider.oninput = () => {
          const v = Number(rpmSlider.value);
          rpmVal.textContent = v;
          if (slotA !== null && slotB !== null) {
              // Only after both A and B exist does the slider edit the active slot
              if (sliderSlot === 'A') {
                  slotA = v;
                  console.log(`[slider] editing A -> ${v}`);
              } else {
                  slotB = v;
                  console.log(`[slider] editing B -> ${v}`);
              }
              console.log(`[state] after slider: A=${slotA} B=${slotB} sliderSlot=${sliderSlot} currentRPM=${currentRPM}`);
          } else {
              // Before B exists, slider is just a candidate value; don't mutate A here
              console.log(`[slider] candidate value → ${v} (A=${slotA}, B=${slotB})`);
          }
      };

      cooldownSlider.oninput = () => cooldownVal.textContent = cooldownSlider.value;

      async function loadSound(url) {
          const response = await fetch(url);
          const arrayBuffer = await response.arrayBuffer();
          return await audioContext.decodeAudioData(arrayBuffer);
      }

      async function init() {
          tickBuffer = await loadSound(tickURL);
          tockBuffer = await loadSound(tockURL);
          chimeBuffer = await loadSound(chimeURL);
      }

      function playBuffer(buffer) {
          const source = audioContext.createBufferSource();
          source.buffer = buffer;
          source.connect(audioContext.destination);
          source.start();
      }

      function togglePacer() {
          const button = document.getElementById("startButton");
          const icon = button.querySelector("i");
          const others = [
              document.getElementById("setRPMButton"),
              document.getElementById("standUpButton"),
              document.getElementById("cooldownButton"),
              document.getElementById("rpmSlider"),
              document.getElementById("cooldownSlider")
          ];

          if (!cadenceLoopActive) {
              requestWakeLock();
              cadenceLoopActive = true;
              startSilentLoop();
              button.innerHTML = '<i class="bi bi-stop-fill me-2"></i>Stop';
              others.forEach(b => b.disabled = false);
              // Resume at last RPM, no forced default
              // setTargetRPM(85, 0);
              cadenceLoop();
          } else {
              cadenceLoopActive = false;
              cooldownActive = false;
              releaseWakeLock();
              if (silentSource) silentSource.stop();
              countdownDisplay.textContent = '';
              if (countdownInterval) clearInterval(countdownInterval);
              if (cooldownTimer) clearInterval(cooldownTimer);
              if (intervalId) clearInterval(intervalId);
              button.innerHTML = '<i class="bi bi-play-fill me-2"></i>Start';
              others.forEach(b => b.disabled = true);
          }
      }

      function setRPM() {
          const v = Number(rpmSlider.value);
          console.log(`\n[setRPM] pressed. slider=${v} A=${slotA} B=${slotB} sliderSlot=${sliderSlot}`);

          if (Number.isNaN(v)) {
              console.warn('[setRPM] slider is NaN; abort.');
              return;
          }

          // First press: define A and ramp to it; leave slider showing A
          if (slotA === null) {
              slotA = v;
              sliderSlot = 'A';
              console.log(`[setRPM] define A=${slotA}; sliderSlot=${sliderSlot}`);
              setTargetRPM(slotA, 5, () => console.log('[setRPM] ramp to A done'));
              return;
          }

          // Second press with a different value → define B and ramp to B
          if (slotB === null && v !== slotA) {
              slotB = v;
              console.log(`[setRPM] define B=${slotB} (A=${slotA})`);
              setTargetRPM(slotB, 5, () => console.log('[setRPM] first ramp to B done'));

              // After pressing, show A for the next press and make slider represent A
              sliderSlot = 'A';
              rpmSlider.value = String(slotA);
              rpmVal.textContent = slotA;
              console.log(`[setRPM] slider resets to A=${slotA}; sliderSlot=${sliderSlot}`);
              console.log(`[state] A=${slotA} B=${slotB} sliderSlot=${sliderSlot}`);
              return;
          }

          // Both A & B exist → flip to whichever slot slider currently represents,
          // then swap slider to the other slot for next time.
          if (slotA !== null && slotB !== null) {
              const target = (sliderSlot === 'A') ? slotA : slotB;
              console.log(`[setRPM] flip target=${target} (from slot ${sliderSlot})`);
              setTargetRPM(target, 5, () => console.log(`[setRPM] flip ramp to ${target} done`));

              sliderSlot = (sliderSlot === 'A') ? 'B' : 'A';
              const nextShown = (sliderSlot === 'A') ? slotA : slotB;
              rpmSlider.value = String(nextShown);
              rpmVal.textContent = nextShown;
              console.log(`[setRPM] now sliderSlot=${sliderSlot}, slider shows ${nextShown}`);
              console.log(`[state] A=${slotA} B=${slotB} sliderSlot=${sliderSlot}`);
          }
      }

      function standUp() {
          const before = currentRPM;

          // Go to 60 over 5s
          setTargetRPM(60, 5, () => {
              // Hold 10s
              setTimeout(() => {
                  if (cooldownActive) {
                      const now = performance.now();
                      const resumeTarget = cooldownTargetAt(now);

                      // Return to where cooldown *should be* now over 5s
                      setTargetRPM(resumeTarget, 5, () => {
                          // If still in phase 2 (80->70 ramp), continue the ramp for the remaining time
                          const phase2End = cooldownStartMs + (cooldownDurationMs * 0.9);
                          const remainingMs = Math.max(0, phase2End - performance.now());
                          if (remainingMs > 0) {
                              setTargetRPM(70, remainingMs / 1000);
                          }
                          // If we're already in the last 10%, we're at 70 and just hold.
                      });
                  } else {
                      // No cooldown—return to the previous (pre-stand) setting over 5s
                      setTargetRPM(before, 5);
                  }
              }, 10000);
          });
      }

      function startCooldown() {
          const minutes = parseInt(cooldownSlider.value, 10);
          cooldownDurationMs = minutes * 60 * 1000;
          cooldownStartMs = performance.now();
          cooldownStartRPM = currentRPM;
          cooldownActive = true;

          // Countdown UI
          if (countdownInterval) clearInterval(countdownInterval);
          countdownInterval = setInterval(() => {
              const elapsed = performance.now() - cooldownStartMs;
              const remaining = Math.max(0, cooldownDurationMs - elapsed);
              const min = Math.floor(remaining / 60000);
              const sec = Math.floor((remaining % 60000) / 1000);
              countdownDisplay.textContent = `Cooldown Time Left: ${min}:${sec.toString().padStart(2,'0')}`;
              if (remaining <= 0) clearInterval(countdownInterval);
          }, 250);

          // Key timestamps
          const endAt    = cooldownStartMs + cooldownDurationMs;      // 100%
          const phase2End = cooldownStartMs + cooldownDurationMs * 0.9; // 90% (last 10% hold at 70)

          // Phase 1: ramp to 80 over 5s
          setTargetRPM(80, 5, () => {
              // Phase 2: linearly to 70 until 90% mark; last 10% hold at 70
              const now = performance.now();
              const remainingMsToPhase2End = Math.max(0, phase2End - now);

              if (remainingMsToPhase2End > 0) {
                  // Ramp 80 -> 70 until 90% point
                  setTargetRPM(70, remainingMsToPhase2End / 1000, () => {
                      // Last 10%: hold 70 until the very end, then chime + stop
                      const lastHoldMs = Math.max(0, endAt - performance.now());
                      if (lastHoldMs > 0) {
                          setTimeout(finishCooldown, lastHoldMs);
                      } else {
                          finishCooldown();
                      }
                  });
              } else {
                  // Already inside the last 10% window—snap to 70 and wait for end
                  setTargetRPM(70, 0);
                  const remainingToEnd = Math.max(0, endAt - performance.now());
                  if (remainingToEnd > 0) {
                      setTimeout(finishCooldown, remainingToEnd);
                  } else {
                      finishCooldown();
                  }
              }
          });
      }

      function cooldownTargetAt(nowMs) {
          if (!cooldownActive) return currentRPM;
          const elapsed = nowMs - cooldownStartMs;
          const phase1 = 5000; // first 5s to 80
          const phase2End = cooldownStartMs + (cooldownDurationMs * 0.9);

          if (elapsed <= 0) return cooldownStartRPM;

          if (elapsed < phase1) {
              const t = elapsed / phase1;
              return cooldownStartRPM + (80 - cooldownStartRPM) * t;
          }

          if (nowMs < phase2End) {
              const t = (nowMs - (cooldownStartMs + phase1)) / (phase2End - (cooldownStartMs + phase1));
              return 80 + (70 - 80) * Math.max(0, Math.min(1, t));
          }

          return 70; // last 10% hold
      }

      function finishCooldown() {
          cooldownActive = false;
          cadenceLoopActive = false;
          // stop any interval/timers if you keep references
          if (countdownInterval) clearInterval(countdownInterval);
          countdownDisplay.textContent = '';

          // Stop the silent loop if it's running
          try { if (silentSource) silentSource.stop(); } catch (e) {}

          // Play the end chime exactly once
          playBuffer(chimeBuffer);

          // If you use Wake Lock:
          if (typeof releaseWakeLock === 'function') releaseWakeLock();

          // Reset UI/buttons
          const startBtn = document.getElementById("startButton");
          startBtn.innerHTML = '<i class="bi bi-play-fill me-2"></i>Start';
          document.getElementById("setRPMButton").disabled = true;
          document.getElementById("standUpButton").disabled = true;
          document.getElementById("cooldownButton").disabled = true;
      }

      function updateCountdown(secondsLeft) {
          const min = Math.floor(secondsLeft / 60);
          const sec = secondsLeft % 60;
          countdownDisplay.textContent = `Cooldown Time Left: ${min}:${sec.toString().padStart(2, '0')}`;
      }

      function setTargetRPM(target, durationSeconds, callback) {
          if (intervalId) clearInterval(intervalId);
          const steps = durationSeconds * 20;
          let count = 0;
          const start = currentRPM;
          intervalId = setInterval(() => {
              count++;
              currentRPM = start + (target - start) * (count / steps);
              updateRPM(currentRPM);
              if (count >= steps) {
                  currentRPM = target;
                  updateRPM(currentRPM);
                  clearInterval(intervalId);
                  if (callback) callback();
              }
          }, 50);
      }

      function updateRPM(rpm) {
          currentRPM = Number(rpm.toFixed(1));
          currentRPMDisplay.textContent = `${currentRPM.toFixed(1)} RPM`;
      }

      function startSilentLoop() {
          const silentBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 2, audioContext.sampleRate);
          silentSource = audioContext.createBufferSource();
          silentSource.buffer = silentBuffer;
          silentSource.loop = true;
          silentSource.connect(audioContext.destination);
          silentSource.start();
      }

      async function cadenceLoop() {
          while (cadenceLoopActive) {
              // If cooldown is active and time is up, stop without playing another tick
              if (cooldownActive) {
                  const now = performance.now();
                  const endAt = cooldownStartMs + cooldownDurationMs;
                  if (now >= endAt) {
                      // Make sure we finish cleanly (plays chime, clears UI, etc.)
                      finishCooldown();
                      break;
                  }
              }

              // Safety: bail if we've been turned off elsewhere
              if (!cadenceLoopActive) break;

              // Play next beat
              playBuffer(cadenceBeat === 0 ? tickBuffer : tockBuffer);
              cadenceBeat = (cadenceBeat + 1) % 4;

              // Wait until next half-revolution (2 sounds per revolution)
              const delay = 60000 / (currentRPM * 2);
              await new Promise(resolve => setTimeout(resolve, delay));
          }
      }

      init();

      window.addEventListener('DOMContentLoaded', () => {

          document.querySelectorAll('.btn').forEach(btn => {
              btn.addEventListener('click', () => {
                  btn.classList.add('active');
                  navigator.vibrate?.(50);
                  btn.disabled = true;
                  setTimeout(() => {
                      btn.disabled = false;
                      btn.classList.remove('active');
                  }, 500);
              });
          });

          document.getElementById("setRPMButton").disabled = true;
          document.getElementById("standUpButton").disabled = true;
          document.getElementById("cooldownButton").disabled = true;
          document.getElementById("rpmSlider").disabled = true;
          document.getElementById("cooldownSlider").disabled = true;
      });
      </script>
    <script>
      if ('serviceWorker' in navigator) {
          window.addEventListener('load', async () => {
              try {
                  const reg = await navigator.serviceWorker.register(
                      '/cadence/service-worker.js?v=v3',  // bump with SW_VERSION
                      { scope: '/cadence/', updateViaCache: 'none' }
                  );
                  reg.update?.(); // ask for updates on load
                  // Optional: force new SW to take control immediately
                  if (reg.waiting) reg.waiting.postMessage('SKIP_WAITING');
              } catch (e) {
                  console.log('SW registration failed', e);
              }
          });
      }
    </script>
  </body>
</html>
